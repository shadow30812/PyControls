# PyControls Mathematical Reference

This document catalogs and provides detailed explanations for all the mathematical formulas, physical laws, and numerical algorithms implemented in the PyControls library. It serves as a bridge between the code implementation and the theoretical first principles.

## 1. Physical Systems (DC Motor)

**Source:** `systems/dc_motor.py`

### 1.1. Fundamental Physics

The DC Motor is modeled as an electromechanical system where electrical energy is converted into mechanical energy. This is represented by two coupled differential equations.

**Electrical Domain (Kirchhoff's Voltage Law):** The sum of voltage drops around the armature loop must equal the applied voltage.

- **i(t)R**: Resistive voltage drop across the armature windings.
- **L di(t)/dt**: Inductive voltage drop which opposes changes in current (electrical inertia).
- **e_b(t) = K_b ω(t)**: The Back-Electromotive Force (Back-EMF). As the motor spins, it acts like a generator, creating a voltage that opposes the input voltage. This term couples the mechanical speed ω back into the electrical equation.

**Equation:** V(t) = i(t)R + L(di(t)/dt) + e_b(t)

**Mechanical Domain (Newton's Second Law for Rotation):** The sum of torques acting on the rotor equals the moment of inertia times angular acceleration.

- **T_m(t) = K_i i(t)**: The motor torque generated by the Lorentz force, directly proportional to the armature current. This term couples the electrical current i into the mechanical equation.
- **J(dω(t)/dt)**: The inertial torque required to accelerate the rotor mass.
- **bω(t)**: Viscous friction torque, which acts against the direction of motion and increases linearly with speed.
- **T_load(t)**: External disturbance torque applied to the shaft.

**Equation:** T_m(t) = J(dω(t)/dt) + bω(t) + T_load(t)

### 1.2. State-Space Representation (Continuous)

To simulate the system numerically or apply modern control techniques, we convert the second-order differential equations into a system of first-order equations. We define the state vector **x = [ω, i]^T**, containing the angular velocity and armature current.

Rearranging the fundamental physics equations to solve for the highest-order derivatives ω̇ and i̇:

**State-Space Form:**

[ω̇]   = [-b/J    -K_b/J] [ω]   + [0      1/J  ] [V       ]<br>
[i̇]     [-K_i/L  -R/L  ] [i]     [1/L    0    ] [T_load  ]

Or more compactly:<br>
**x˙ = Ax + Bu**

- **System Matrix (A)**: Characterizes the internal dynamics. The eigenvalues of this matrix determine the system's stability and natural response speed (time constants).
- **Input Matrix (B)**: Describes how external inputs (Voltage and Load) enter the system dynamics. Note that Voltage drives the current derivative directly, while Load Torque drives the acceleration directly.
- **Output Equation (y = Cx + Du)**: We assume sensors measure both states directly without algebraic feedthrough from the inputs.

**Output:**

[y_1]   = [1  0] [ω]   + [0  0] [V       ]<br>
[y_2]     [0  1] [i]     [0  0] [T_load  ]

### 1.3. Transfer Functions (SISO)

For classical control design (PID) and frequency analysis, we move to the Laplace domain (s-domain).

**Plant Transfer Function (G_p(s)):** Deriving G_p(s) by setting T_load = 0 and substituting the electrical equation into the mechanical equation yields a second-order system:

**G_p(s) = ω(s)/V(s) = K_i / [(JL)s² + (JR + bL)s + (bR + K_i K_b)]**

This denominator represents the characteristic equation of the motor. The term K_i K_b appears here, reflecting the "electrical damping" effect caused by the Back-EMF loop.

**PID Controller Transfer Function (C(s)):** The ideal PID controller in the Laplace domain is represented as:

**C(s) = (K_d s² + K_p s + K_i) / s**

(Note: In implementation, this is treated as a rational function with polynomial coefficients [K_d, K_p, K_i] for the numerator and [1, 0] for the denominator to facilitate proper polynomial convolution).

**Closed-Loop Transfer Function (T(s)):** The relationship between the Reference Setpoint and the actual Output Speed is:

**T(s) = C(s)G_p(s) / (1 + C(s)G_p(s))**

---

## 2. Solvers & Numerical Methods

**Source:** `core/solver.py`

### 2.1. Matrix Exponential

To solve linear differential equations of the form **ẋ = Ax**, we require the matrix exponential **e^(At)**.

PyControls implements this from scratch using the **Scaling and Squaring method** combined with a Taylor Series approximation. This method is preferred for its numerical stability.

- **Scaling**: The matrix A is scaled down by 2^s until its norm is small enough (‖A‖ < 0.5) to ensure rapid convergence of the Taylor series.
- **Taylor Series Approximation**: For the scaled matrix X = A/2^s, the exponential is approximated by a truncated series:

**e^X ≈ I + X + X²/2! + ... + X^k/k!**

- **Squaring**: The result is then squared s times to recover the exponential of the original matrix A.

### 2.2. Exact Discretization (Zero-Order Hold)

To simulate continuous physical systems on a digital computer, we use the Zero-Order Hold (ZOH) assumption: inputs u(t) are held constant between time steps Δt. This yields an exact solution to the differential equation over that interval, avoiding integration errors common in Euler or simple Runge-Kutta methods for linear systems.

- **Φ (Phi)**: State Transition Matrix. Describes how the system evolves naturally from x_k to x_{k+1}.
- **Γ (Gamma)**: Input Matrix. Describes the accumulated effect of the constant input u_k over the interval.

**Φ = e^(AΔt)**

**Γ = ∫₀^(Δt) e^(Aτ) dτ B**

**Implementation Trick (Van Loan's Method):** We construct a larger block matrix M to compute both integrals simultaneously via a single matrix exponential:

**M = [A    B  ]  ⟹  e^(MΔt) = [Φ    Γ]**
    **[0    0  ]              [0    I]**

### 2.3. Adaptive Runge-Kutta (Dormand-Prince RK45)

For non-linear systems where exact discretization is impossible, we use the Dormand-Prince method. This is an explicit method that calculates two approximations of the solution at each step: one of 4th order and one of 5th order.

**Intermediate Slopes (k_i)**: The solver evaluates the derivative function f(t, x, u) at 7 different points (stages) within the time step h:

(The specific stage calculations involve weighted combinations of previous slopes—the exact coefficients are from the Dormand-Prince tableau)

**5th Order Update (y_{n+1})**: This is the candidate solution used to advance the simulation.

**4th Order Update (y_{n+1}*)**: This is used solely for error estimation.

**Error Estimate & Adaptation**: The local truncation error ε is estimated by the difference between the 5th and 4th order solutions. The step size h is then adjusted dynamically: if error is low, h increases (to save compute time); if error is high, h decreases (to maintain accuracy).

**h_new = 0.9h · (ε_tol / ε)^0.2**

---

## 3. Estimation & Kalman Filters

**Sources:** `core/estimator.py`, `core/ekf.py`

### 3.1. Standard Kalman Filter (Linear)

The Standard Kalman Filter is an optimal recursive estimator for linear systems with Gaussian noise. It minimizes the mean squared error of the estimated state.

**Prediction (Time Update):** Projects the state and uncertainty estimate forward in time using the system model.

**x̂_{k|k-1} = Φ x̂_{k-1|k-1} + Γ u_k**

**P_{k|k-1} = Φ P_{k-1|k-1} Φ^T + Q**

- **Q**: Process Noise Covariance. Represents uncertainty in the model physics itself.

**Correction (Measurement Update):** Adjusts the projected estimate based on actual sensor measurements.

**ỹ_k = z_k - C x̂_{k|k-1}** (Innovation)

**S_k = C P_{k|k-1} C^T + R** (Innovation Covariance)

**K_k = P_{k|k-1} C^T S_k^(-1)** (Optimal Kalman Gain)

**x̂_{k|k} = x̂_{k|k-1} + K_k ỹ_k**

**P_{k|k} = (I - K_k C) P_{k|k-1}**

- **R**: Measurement Noise Covariance. Represents uncertainty in the sensor readings. The Gain K balances trust between the Model (P) and the Sensors (R).

### 3.2. Extended Kalman Filter (Non-Linear)

The EKF adapts the linear Kalman Filter to non-linear systems by linearizing the dynamics around the current state estimate. In this project, it is used for dual estimation: estimating states (Speed, Current) and parameters (Inertia J, Friction b) simultaneously.

**Jacobian via Complex Step Differentiation:** Unlike Finite Differences which suffer from subtractive cancellation errors, Complex Step Differentiation (CSD) provides Jacobian approximations accurate to machine precision. We exploit the Cauchy-Riemann equations:

**J_{ij} ≈ ∂f_i/∂x_j ≈ Im(f_i(x + jε e_j)) / ε**

Here, ε is a very small number (e.g., 10^(-20)), yet the calculation remains numerically stable.

**Prediction:** The state is propagated using the full non-linear function f(x, u). Linearity is only assumed for the covariance propagation via the Jacobian F.

**x̂_{k|k-1} = x̂_{k-1|k-1} + ∫_{t_{k-1}}^{t_k} ẋ(t) dt** (where ẋ = f(x, u))

**F = I + (∂f/∂x)|_{x̂_{k|k-1}} Δt** (Linearized State Transition)

**P_{k|k-1} = F P_{k-1|k-1} F^T + Q**

**Correction:** Similarly, the measurement function h(x) is linearized to form matrix H.

**H = ∂h/∂x|_{x̂_{k|k-1}}**

**y_pred = h(x̂_{k|k-1})**

(The update equations for x̂, P, and K remain identical to the Standard KF, substituting H for C)

---

## 4. Analysis & Metrics

**Source:** `core/analysis.py`, `core/state_space.py`

### 4.1. Frequency Response

The frequency response describes how the system amplifies and shifts sinusoidal inputs at different frequencies. It is evaluated directly from the State-Space matrices, which avoids the numerical errors associated with high-order polynomial operations.

**H(jω) = C(jωI - A)^(-1) B + D**

**Magnitude (dB):** Describes the gain of the system.

**M_dB = 20 log₁₀(|H(jω)|)**

**Phase (deg):** Describes the time delay (lag) introduced by the system dynamics.

**ϕ = degrees(∠H(jω))**

### 4.2. Stability Margins

Stability margins quantify the robustness of a feedback control system. They define how much the system parameters can change before the system becomes unstable.

**Phase Crossover Frequency (ω_pc):** The frequency where the phase lag reaches -180°. At this point, the feedback becomes positive.

**Gain Margin:** The amount of additional gain (in dB) required at ω_pc to bring the loop gain to 0 dB (instability). Calculated as **-M_dB(ω_pc)**.

**Gain Crossover Frequency (ω_gc):** The frequency where the open-loop magnitude is 0 dB (unity gain).

**Phase Margin:** The additional phase lag required at ω_gc to reach -180°. Calculated as **180° + ϕ(ω_gc)**.

### 4.3. Step Response Metrics

These time-domain metrics quantify the performance of the closed-loop system in response to a sudden change in setpoint (step input).

**Overshoot (%):** Indicates the relative amount by which the system exceeds the target value. High overshoot suggests a low damping ratio.

**%OS = ((y_peak - y_final) / y_final) × 100**

**Rise Time:** The time required for the response to rise from 10% to 90% of its final value. It is a measure of the system's speed or bandwidth.

**t_r = t_{90%} - t_{10%}**

**Settling Time:** The time required for the response curve to reach and stay within a specific error band (typically ±2%) of the final value. It measures how quickly oscillations die out.

---

## 5. Control

**Source:** `config.py`, `main.py`

### 5.1. PID Control Law (Time Domain)

The Proportional-Integral-Derivative controller is the standard industrial control algorithm.

**Error Signal:** e(t) = Setpoint - Measured Output

**Proportional (K_p):** Reacts to the current error. Provides immediate corrective action.

**Integral (K_i):** Reacts to the accumulation of past errors. Used to eliminate steady-state error (offset).

**Derivative (K_d):** Reacts to the rate of change of the error. Provides a predictive action to dampen overshoot and improve stability.

**Control Output:**

**V(t) = K_p e(t) + K_i ∫₀^t e(τ) dτ + K_d (de(t)/dt)**

### 5.2. Augmented State for EKF Estimation

In the parameter estimation demo, we model the unknown parameters as state variables. Specifically, to estimate disturbance (or parameters), we treat them as slowly varying constants.

The state vector is augmented:

**x_aug = [ω, i, T_dist]**

The disturbance T_dist is modeled as a **Random Walk process**. This means we assume its derivative is zero, driven only by process noise. This allows the Kalman Filter to "track" the value as it drifts or steps.

---

_End of Document_
